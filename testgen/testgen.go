package testgen

import (
	"fmt"
	"net/url"
)

type tGen struct {
	generatedTests []string
	current        int
}

var GeneratedTests = tGen{generatedTests: nil, current: -1}

func AppendToTest(s string) {
	GeneratedTests.generatedTests[GeneratedTests.current] += s
}

func CurrentTestString() string {
	return GeneratedTests.generatedTests[GeneratedTests.current]
}

func NewTest() {
	GeneratedTests.current++
	GeneratedTests.generatedTests = append(GeneratedTests.generatedTests, "")
}

func inFromValues(body url.Values) string {
	var result string
	for k, v := range body {
		result += fmt.Sprintf(`data.NewEntry("%s", "%s")`, k, v[0])
		result += ", \n				"
	}
	return result
}

func GenerateExpectedStruct(query url.Values, body url.Values, apiCall string) string {
	var result string

	meetingID := query.Get("meetingID")
	if meetingID == "" {
		meetingID = body.Get("meetingID")
	}
	attendeePW := query.Get("attendeePW")
	if attendeePW == "" {
		attendeePW = body.Get("attendeePW")
	}
	moderatorPW := query.Get("moderatorPW")
	if moderatorPW == "" {
		moderatorPW = body.Get("moderatorPW")
	}

	switch apiCall {
	case "create":
		result += fmt.Sprintf(`
			// TODO: fill with expected structure
			expected := tests.CreateResponse{
				Returncode: "SUCCESS",
				MeetingID: "%s",
				ModeratorPW: "%s",
				AttendeePW: "%s",
			}`, meetingID, moderatorPW, attendeePW)
	case "end":
		result += `
			// TODO: fill with expected structure
			expected := tests.EndResponse{
				Returncode: "SUCCESS",
				MessageKey: "",
			}`
	case "getMeetings":
		result += `
			// TODO: fill with expected structure
			expected := tests.GetMeetingsResponse{
				Returncode: "SUCCESS",
				Meetings: []tests.MeetingInfo{
					//tests.MeetingInfo{MeetingID: <fill meetingID here>},
					//tests.MeetingInfo{MeetingID: <fill meetingID here>},
				},
			}`
	case "getMeetingInfo":
		result += fmt.Sprintf(`
			// TODO: fill with expected structure
			expected := tests.GetMeetingInfoResponse{
				Returncode: "SUCCESS",
				MeetingID: "%s",
				// ModeratorPW: "",
				// AttendeePW: "",
			}`, meetingID)
	case "getRecordings":
		result += `
			// TODO: fill with expected structure
			expected := tests.GetRecordingsResponse{
				Returncode: "SUCCESS",
			}`
	case "isMeetingRunning":
		result += `
			// TODO: fill with expected structure
			expected := tests.IsMeetingRunningResponse{
				Returncode: "SUCCESS",
				Running: false,
			}`
	case "publishRecordings":
		publish := query.Get("publish")
		if publish == "" {
			publish = body.Get("publish")
		}
		result += fmt.Sprintf(`
			// TODO: fill with expected structure
			expected := tests.PublishRecordingResponse{
				Returncode: "SUCCESS",
				Published: %s,
			}`, publish)
	case "deleteRecordings":
		result += `
			// TODO: fill with expected structure
			expected := tests.DeleteRecordingsResponse{
				Returncode: "SUCCESS",
				Deleted: true
			}`
	case "join":
		result += `
			var expected interface{}`
	}
	return result
}

func GenerateTestApplicationXML(body string, server string, apiCall string, query string, testcomment string) {
	u, err := url.Parse(server)
	if err != nil {
		fmt.Println(err)
		return
	}
	queryValues, _ := url.ParseQuery(query)

	str := fmt.Sprintf(`
		// ################################################################
		/*
			Test generated by PostMate
			application/xml %s
			Query: %s
			Body:  %s
			%s
		*/
		{
			httpParams := RequestParameters{"http", "%s", %s, "%s", "POST"}
	
			in := CreateMap(
				%s
			)
			%s

			body := `+"`%s`"+`

			passed, response, errs := DoTestPost(httpParams, "%s", in, body, ContentTypeXML, expected)
			ReportPassing("%s[POST] application/xml generated by PostMate", passed, errs, response)
		}
		`,
		apiCall, query, body, testcomment,
		u.Hostname(), u.Port(), u.Path,
		inFromValues(queryValues),
		GenerateExpectedStruct(queryValues, url.Values{}, apiCall),
		body, apiCall,
		apiCall,
	)

	AppendToTest(str)
}

func GenerateTestURLEncoded(body url.Values, server string, apiCall string, query string, testcomment string) {
	u, err := url.Parse(server)
	if err != nil {
		fmt.Println(err)
		return
	}
	queryValues, _ := url.ParseQuery(query)

	str := fmt.Sprintf(`
		// ################################################################
		/*
			Test generated by PostMate
			x-www-form-urlencoded %s
			Query: %s
			Body:  %s
			%s
		*/
		{
			httpParams := RequestParameters{"http", "%s", %s, "%s", "POST"}
	
			in := CreateMap(
				%s
			)
			%s

			body := `+"`%s`"+`

			passed, response, errs := DoTestPost(httpParams, "%s", in, body, ContentTypeURLEncoded, expected)
			ReportPassing("%s[POST] urlencoded generated by PostMate", passed, errs, response)
		}
		`,
		apiCall, query, body.Encode(), testcomment,
		u.Hostname(), u.Port(), u.Path,
		inFromValues(queryValues),
		GenerateExpectedStruct(queryValues, body, apiCall),
		body.Encode(), apiCall,
		apiCall,
	)

	AppendToTest(str)
}

func GenerateTestFileHeader(id int) {
	str := fmt.Sprintf(`
package main

import (
	"github.com/mconftec/mconf-api/tests/data"
	tests "github.com/mconftec/mconf-api/tests/models"
)

func useCases%d() {
`, id)
	AppendToTest(str)
}

func GenerateTestFileFooter() {
	str := fmt.Sprintf(
		`
	// ################################################################

	ReportStats()
	ResetStats()
}`)
	AppendToTest(str)
}
